import streamlit as st
import cv2
import numpy as np
from PIL import Image
import io
from skimage.feature import local_binary_pattern
import pathlib

# Page config
st.set_page_config(
    page_title="Medical Image Preprocessor",
    page_icon="üî¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for beautiful light theme
st.markdown("""
    <style>
    /* Main container */
    .main {
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #f5f7fa 0%, #e8eef5 100%);
    }
    
    /* Sidebar styling */
    [data-testid="stSidebar"] {
        background: linear-gradient(180deg, #ffffff 0%else:
    # Empty state else:
    # Empty state with instructions
    st.markdown("---")
    st.markdown("""
        <div style='text-align: center; padding: 3.5rem; background: white; border-radius: 20px; 
                    box-shadow: 0 4px 20px rgba(102, 126, 234, 0.1); border: 1px solid #e8eef5;'>
            <h2 style='color: #667eea; margin-bottom: 1rem;'>üëã Welcome!</h2>
            <p style='font-size: 1.2rem; color: #495057; margin: 1.5rem 0;'>
                Get started by uploading a medical image above
            </p>
            <div style='background: #f8f9fa; padding: 1.5rem; border-radius: 12px; margin-top: 1.5rem;'>
                <p style='color: #6c757d; margin: 0.5rem 0;'>
                    üì∏ <strong>Supported formats:</strong> PNG, JPG, JPEG, TIFF
                </p>
                <p style='color: #6c757d; margin: 0.5rem 0;'>
                    üéØ <strong>Perfect for:</strong> X-rays, CT scans, and medical imaging
                </p>
                <p style='color: #6c757d; margin: 0.5rem 0;'>
                    ‚ö° <strong>Fast processing</strong> with professional results
                </p>
            </div>
        </div>
    """, unsafe_allow_html=True)s
    st.markdown("---")
    st.markdown("""
        <div style='text-align: center; padding: 3.5rem; background: white; border-radius: 20px; 
                    box-shadow: 0 4px 20px rgba(102, 126, 234, 0.1); border: 1px solid #e8eef5;'>
            <h2 style='color: #667eea; margin-bottom: 1rem;'>üëã Welcome!</h2>
            <p style='font-size: 1.2rem; color: #495057; margin: 1.5rem 0;'>
                Get started by uploading a medical image above
            </p>
            <div style='background: #f8f9fa; padding: 1.5rem; border-radius: 12px; margin-top: 1.5rem;'>
                <p style='color: #6c757d; margin: 0.5rem 0;'>
                    üì∏ <strong>Supported formats:</strong> PNG, JPG, JPEG, TIFF
                </p>
                <p style='color: #6c757d; margin: 0.5rem 0;'>
                    üéØ <strong>Perfect for:</strong> X-rays, CT scans, and medical imaging
                </p>
                <p style='color: #6c757d; margin: 0.5rem 0;'>
                    ‚ö° <strong>Fast processing</strong> with professional results
                </p>
            </div>
        </div>
    """, unsafe_allow_html=True)
        border-right: 2px solid #e3e8ef;
    }
    
    [data-testid="stSidebar"] h3 {
        color: #2c3e50 !important;
        font-weight: 700;
    }
    
    [data-testid="stSidebar"] p {
        color: #5a6c7d !important;
    }
    
    /* Header styling */
    .main-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 2.5rem;
        border-radius: 20px;
        text-align: center;
        margin-bottom: 2rem;
        box-shadow: 0 10px 40px rgba(102, 126, 234, 0.2);
    }
    
    .main-header h1 {
        color: white;
        font-size: 3rem;
        font-weight: 800;
        margin: 0;
        text-shadow: 0px 2px 10px rgba(0,0,0,0.1);
    }
    
    .main-header p {
        color: rgba(255,255,255,0.95);
        font-size: 1.2rem;
        margin-top: 0.5rem;
        font-weight: 400;
    }
    
    /* Card styling */
    .image-card {
        background: white;
        padding: 1.5rem;
        border-radius: 20px;
        box-shadow: 0 4px 20px rgba(102, 126, 234, 0.08);
        margin-bottom: 1rem;
        transition: all 0.3s ease;
        border: 1px solid #e8eef5;
    }
    
    .image-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 30px rgba(102, 126, 234, 0.15);
        border-color: #667eea;
    }
    
    /* Button styling */
    .stButton>button {
        width: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-weight: 600;
        font-size: 1.1rem;
        padding: 0.75rem 2rem;
        border: none;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.25);
        transition: all 0.3s ease;
        letter-spacing: 0.5px;
    }
    
    .stButton>button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4);
    }
    
    /* Download button */
    .stDownloadButton>button {
        width: 100%;
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        font-weight: 600;
        font-size: 1rem;
        padding: 0.75rem 2rem;
        border: none;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(17, 153, 142, 0.25);
        transition: all 0.3s ease;
    }
    
    .stDownloadButton>button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 25px rgba(17, 153, 142, 0.4);
    }
    
    /* File uploader */
    [data-testid="stFileUploader"] {
        background: white;
        padding: 2rem;
        border-radius: 16px;
        border: 2px dashed #b8c5d6;
        box-shadow: 0 2px 10px rgba(102, 126, 234, 0.05);
        transition: all 0.3s ease;
    }
    
    [data-testid="stFileUploader"]:hover {
        border-color: #667eea;
        box-shadow: 0 4px 20px rgba(102, 126, 234, 0.1);
    }
    
    /* Radio buttons */
    .stRadio > div {
        background: #f8f9fa;
        padding: 1rem;
        border-radius: 12px;
        border: 1px solid #e3e8ef;
    }
    
    .stRadio > div:hover {
        background: #f0f4f8;
        border-color: #667eea;
    }
    
    /* Info boxes */
    .stAlert {
        border-radius: 12px;
        border-left: 4px solid #667eea;
        background: #f0f4ff;
        color: #2c3e50;
    }
    
    /* Success message */
    .success-banner {
        background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        color: white;
        padding: 1.2rem;
        border-radius: 16px;
        text-align: center;
        font-weight: 600;
        font-size: 1.1rem;
        margin: 1.5rem 0;
        box-shadow: 0 4px 20px rgba(17, 153, 142, 0.2);
    }
    
    /* Image container */
    .stImage {
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.08);
    }
    
    /* Subheader styling */
    .stMarkdown h3 {
        color: #2c3e50;
        font-weight: 700;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
    }
    
    .stMarkdown h4 {
        color: #495057;
        font-weight: 600;
    }
    
    /* Metrics styling */
    [data-testid="stMetricValue"] {
        color: #2c3e50;
        font-weight: 700;
    }
    
    [data-testid="stMetricLabel"] {
        color: #6c757d;
        font-weight: 500;
    }
    
    /* Divider */
    hr {
        border-color: #e3e8ef;
        margin: 2rem 0;
    }
    
    /* Hide default Streamlit branding */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    
    /* Spinner */
    .stSpinner > div {
        border-top-color: #667eea !important;
    }
    
    /* General text colors */
    p {
        color: #495057;
    }
    
    /* Markdown text */
    .stMarkdown {
        color: #495057;
    }
    </style>
""", unsafe_allow_html=True)

# Animated Header
st.markdown("""
    <div class="main-header">
        <h1>üî¨ Medical Image Preprocessor</h1>
        <p>‚ú® Professional AI-powered enhancement for medical imaging ‚ú®</p>
    </div>
""", unsafe_allow_html=True)

# Sidebar for method selection
st.sidebar.markdown("### ‚öôÔ∏è Preprocessing Methods")
st.sidebar.markdown("---")

# Method options with emojis
method_options = {
    "üßπ Text Removal": {
        "name": "1. Text Removal (Inpainting)",
        "description": "Removes bright text/annotations from images using threshold detection and inpainting.",
        "icon": "üßπ",
        "color": "#FF6B6B"
    },
    "‚ú® BPDFHE": {
        "name": "2. BPDFHE (Brightness Preserving)",
        "description": "Advanced fuzzy logic-based histogram equalization that preserves brightness. Best for chest X-rays.",
        "icon": "‚ú®",
        "color": "#4ECDC4"
    },
    "üé® CLAHE Complete": {
        "name": "3. CLAHE + Constant + Gamma + Histogram",
        "description": "4-step pipeline: CLAHE ‚Üí Contrast adjustment ‚Üí Gamma correction ‚Üí Histogram equalization.",
        "icon": "üé®",
        "color": "#95E1D3"
    },
    "‚ö° CLAHE + Gamma": {
        "name": "4. CLAHE + Gamma Correction",
        "description": "Simple 2-step enhancement with CLAHE and gamma correction. Fast and effective.",
        "icon": "‚ö°",
        "color": "#F38181"
    },
    "üîç CLAHE + LBP": {
        "name": "5. CLAHE-YCrCb + LBP",
        "description": "CLAHE in YCrCb color space + Local Binary Pattern texture extraction for ML features.",
        "icon": "üîç",
        "color": "#AA96DA"
    },
    "üìä Histogram EQ": {
        "name": "6. Histogram Equalization",
        "description": "Basic global histogram equalization for quick contrast enhancement.",
        "icon": "üìä",
        "color": "#FCBAD3"
    }
}

method_choice = st.sidebar.radio(
    "Select a method:",
    list(method_options.keys()),
    label_visibility="collapsed"
)

method = method_options[method_choice]["name"]

st.sidebar.markdown("---")
st.sidebar.markdown("### üìñ About This Method")
st.sidebar.info(method_options[method_choice]["description"])

st.sidebar.markdown("---")
st.sidebar.markdown("### üí° Quick Tips")
st.sidebar.markdown("""
<div style='background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); 
            padding: 1rem; 
            border-radius: 12px; 
            border-left: 4px solid #4caf50;
            color: #2c3e50;'>
<p style='margin: 0; padding: 0.3rem 0; color: #2c3e50;'><strong>‚Ä¢ Text Removal:</strong> Best for annotated images</p>
<p style='margin: 0; padding: 0.3rem 0; color: #2c3e50;'><strong>‚Ä¢ BPDFHE:</strong> Best overall quality</p>
<p style='margin: 0; padding: 0.3rem 0; color: #2c3e50;'><strong>‚Ä¢ CLAHE methods:</strong> Fast processing</p>
<p style='margin: 0; padding: 0.3rem 0; color: #2c3e50;'><strong>‚Ä¢ LBP:</strong> For feature extraction</p>
</div>
""", unsafe_allow_html=True)

st.sidebar.markdown("---")
st.sidebar.markdown("""
    <div style='text-align: center; padding: 1rem;'>
        <p style='font-size: 0.9rem; color: #6c757d;'>Built with ‚ù§Ô∏è using Streamlit</p>
    </div>
""", unsafe_allow_html=True)


# ==================== PREPROCESSING FUNCTIONS ====================

def remove_text(img, thresh_val=200, dilate_kernel=(5, 5), dilate_iter=2, inpaint_radius=3):
    """Method 1: Text Removal"""
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    _, thresh = cv2.threshold(gray, thresh_val, 255, cv2.THRESH_BINARY)
    kernel = np.ones(dilate_kernel, np.uint8)
    mask = cv2.dilate(thresh, kernel, iterations=dilate_iter)
    cleaned = cv2.inpaint(img, mask, inpaint_radius, cv2.INPAINT_TELEA)
    return cleaned


def bpdfhe_preprocessing(img):
    """Method 2: BPDFHE - Brightness Preserving Dynamic Fuzzy Histogram Equalization"""
    
    def _tri_fuzzy_memberships(n_bins=256):
        x = np.arange(n_bins, dtype=np.float32)
        dark = np.clip(1 - x/127.0, 0, 1)
        mid = np.maximum(1 - np.abs(x-127)/64.0, 0)
        bright = np.clip((x-128)/127.0, 0, 1)
        s = dark + mid + bright + 1e-6
        return dark/s, mid/s, bright/s
    
    def _smooth_hist(h, ksize=7):
        k = cv2.getGaussianKernel(ksize, ksize/3)
        k = (k @ k.T).flatten()
        k = k / k.sum()
        pad = ksize // 2
        hp = np.pad(h, (pad, pad), mode='reflect')
        return np.correlate(hp, k, mode='valid')
    
    def _find_minima(h, min_gap=32, max_regions=4):
        candidates = []
        for i in range(2, len(h)-2):
            if h[i] < h[i-1] and h[i] < h[i+1] and h[i] <= h[i-2] and h[i] <= h[i+2]:
                candidates.append(i)
        picks = []
        for c in candidates:
            if not picks or c - picks[-1] >= min_gap:
                picks.append(c)
            if len(picks) >= (max_regions-1):
                break
        picks = [p for p in picks if 8 <= p <= 247]
        return sorted(picks)
    
    def _equalize_region(cdf, lo, hi):
        lo = int(lo); hi = int(hi)
        lo = max(0, lo); hi = min(len(cdf) - 1, hi)
        if lo >= hi:
            return np.arange(256, dtype=np.uint8)
        c_lo, c_hi = cdf[lo], cdf[hi]
        den = max(c_hi - c_lo, 1e-8)
        m = np.arange(lo, hi + 1)
        m = np.clip(m, 0, len(cdf) - 1).astype(np.int32)
        mapped = (cdf[m] - c_lo) / den
        mapped = np.round(mapped * (hi - lo) + lo).astype(np.uint8)
        lut = np.arange(256, dtype=np.uint8)
        lut[lo:hi+1] = np.clip(mapped, 0, 255).astype(np.uint8)
        return lut
    
    # Convert to grayscale if needed
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Robust normalization
    p_low, p_high = 1.0, 99.0
    lo, hi = np.percentile(gray.astype(np.float32), [p_low, p_high])
    if hi <= lo:
        hi = lo + 1.0
    gray_uint8 = np.clip((gray.astype(np.float32) - lo) / (hi - lo), 0, 1) * 255.0
    gray_uint8 = gray_uint8.astype(np.uint8)
    
    # BPDFHE algorithm
    hist = cv2.calcHist([gray_uint8], [0], None, [256], [0, 256]).flatten().astype(np.float32)
    f1, f2, f3 = _tri_fuzzy_memberships(256)
    fh = _smooth_hist(hist * (f1 + f2 + f3), ksize=11)
    splits = _find_minima(fh, min_gap=32, max_regions=4)
    
    regions = []
    last = 0
    for s in splits:
        regions.append((last, s))
        last = s + 1
    regions.append((last, 255))
    
    pdf = fh / (fh.sum() + 1e-8)
    cdf = np.cumsum(pdf)
    lut = np.arange(256, dtype=np.uint8)
    
    for (lo, hi) in regions:
        lut_region = _equalize_region(cdf, lo, hi)
        lut[lo:hi+1] = lut_region[lo:hi+1]
    
    y0 = gray_uint8.astype(np.uint8)
    y_map = cv2.LUT(y0, lut).astype(np.float32)
    m0, m1 = float(y0.mean()), float(y_map.mean())
    y_bp = np.clip(y_map + (m0 - m1), 0, 255)
    
    blend = 0.6
    out = (1.0 - blend) * y0.astype(np.float32) + blend * y_bp
    result = np.clip(out, 0, 255).astype(np.uint8)
    
    return cv2.cvtColor(result, cv2.COLOR_GRAY2BGR)


def clahe_constant_gamma_hist(img):
    """Method 3: CLAHE + Constant Adjustment + Gamma + Histogram Equalization"""
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Step 1: CLAHE
    clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
    img_processed = clahe.apply(gray)
    
    # Step 2: Constant Adjustment
    alpha, beta = 1.2, 20
    img_processed = cv2.convertScaleAbs(img_processed, alpha=alpha, beta=beta)
    
    # Step 3: Gamma Correction
    gamma = 1.5
    gamma_table = np.array([((i / 255.0) ** (1.0/gamma)) * 255
                            for i in np.arange(256)]).astype("uint8")
    img_processed = cv2.LUT(img_processed, gamma_table)
    
    # Step 4: Histogram Equalization
    img_processed = cv2.equalizeHist(img_processed)
    
    return cv2.cvtColor(img_processed, cv2.COLOR_GRAY2BGR)


def clahe_gamma(img):
    """Method 4: CLAHE + Gamma Correction"""
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Step 1: CLAHE
    clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
    img_processed = clahe.apply(gray)
    
    # Step 2: Gamma Correction
    gamma = 1.5
    gamma_table = np.array([((i / 255.0) ** (1.0/gamma)) * 255
                            for i in np.arange(256)]).astype("uint8")
    img_processed = cv2.LUT(img_processed, gamma_table)
    
    return cv2.cvtColor(img_processed, cv2.COLOR_GRAY2BGR)


def clahe_ycrcb_lbp(img):
    """Method 5: CLAHE-YCrCb + LBP"""
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    
    # Step 1: CLAHE on Y channel (YCrCb)
    img_bgr = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)
    ycrcb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2YCrCb)
    y, cr, cb = cv2.split(ycrcb)
    
    clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8, 8))
    y_clahe = clahe.apply(y)
    
    ycrcb_clahe = cv2.merge((y_clahe, cr, cb))
    img_bgr_clahe = cv2.cvtColor(ycrcb_clahe, cv2.COLOR_YCrCb2BGR)
    clahe_img = cv2.cvtColor(img_bgr_clahe, cv2.COLOR_BGR2GRAY)
    
    # Step 2: Local Binary Pattern (LBP)
    radius = 3
    n_points = 8 * radius
    lbp = local_binary_pattern(clahe_img, n_points, radius, method="uniform")
    
    # Normalize LBP to 0‚Äì255
    lbp_normalized = np.uint8(255 * (lbp - lbp.min()) / (lbp.max() - lbp.min() + 1e-8))
    
    return cv2.cvtColor(lbp_normalized, cv2.COLOR_GRAY2BGR)


def histogram_equalization(img):
    """Method 6: Histogram Equalization"""
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if len(img.shape) == 3 else img
    img_processed = cv2.equalizeHist(gray)
    return cv2.cvtColor(img_processed, cv2.COLOR_GRAY2BGR)


# ==================== MAIN APP ====================

# Create columns for better layout
col_upload, col_info = st.columns([2, 1])

with col_upload:
    st.markdown("### üì§ Upload Your Image")
    uploaded_file = st.file_uploader(
        "Drag and drop or click to browse",
        type=["png", "jpg", "jpeg", "tiff", "tif"],
        label_visibility="collapsed"
    )

with col_info:
    st.markdown("### üìã Supported Formats")
    st.markdown("""
    <div style='background: white; padding: 1rem; border-radius: 12px; 
                border: 1px solid #e8eef5; box-shadow: 0 2px 10px rgba(102, 126, 234, 0.05);'>
        <p style='margin: 0.5rem 0; color: #495057;'>‚úÖ <strong>PNG</strong></p>
        <p style='margin: 0.5rem 0; color: #495057;'>‚úÖ <strong>JPG/JPEG</strong></p>
        <p style='margin: 0.5rem 0; color: #495057;'>‚úÖ <strong>TIFF</strong></p>
        <p style='margin: 0.8rem 0 0.5rem 0; color: #6c757d; font-size: 0.9rem;'><strong>Max size:</strong> 200MB</p>
    </div>
    """, unsafe_allow_html=True)

if uploaded_file is not None:
    st.markdown("---")
    
    # Read image
    image = Image.open(uploaded_file)
    img_array = np.array(image)
    
    # Convert RGB to BGR for OpenCV
    if len(img_array.shape) == 3 and img_array.shape[2] == 3:
        img_bgr = cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR)
    elif len(img_array.shape) == 3 and img_array.shape[2] == 4:
        img_bgr = cv2.cvtColor(img_array, cv2.COLOR_RGBA2BGR)
    else:
        img_bgr = cv2.cvtColor(img_array, cv2.COLOR_GRAY2BGR)
    
    # Image info
    st.markdown("### üìä Image Information")
    info_col1, info_col2, info_col3, info_col4 = st.columns(4)
    with info_col1:
        st.metric("Width", f"{img_array.shape[1]}px")
    with info_col2:
        st.metric("Height", f"{img_array.shape[0]}px")
    with info_col3:
        st.metric("Channels", img_array.shape[2] if len(img_array.shape) == 3 else 1)
    with info_col4:
        st.metric("Format", uploaded_file.type.split('/')[-1].upper())
    
    st.markdown("---")
    
    # Display original image in card
    st.markdown("### üñºÔ∏è Image Preview")
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown('<div class="image-card">', unsafe_allow_html=True)
        st.markdown("#### üì∏ Original Image")
        st.image(image, width="stretch")
        st.markdown('</div>', unsafe_allow_html=True)
    
    # Process button with icon
    st.markdown("<br>", unsafe_allow_html=True)
    process_col1, process_col2, process_col3 = st.columns([1, 2, 1])
    with process_col2:
        process_button = st.button("üöÄ PROCESS IMAGE NOW", type="primary", width="stretch")
    
    if process_button:
        with st.spinner("‚è≥ Processing your image... Please wait"):
            # Apply selected method
            if "Text Removal" in method:
                processed = remove_text(img_bgr)
            elif "BPDFHE" in method:
                processed = bpdfhe_preprocessing(img_bgr)
            elif "CLAHE + Constant + Gamma + Histogram" in method:
                processed = clahe_constant_gamma_hist(img_bgr)
            elif "CLAHE + Gamma Correction" in method:
                processed = clahe_gamma(img_bgr)
            elif "CLAHE-YCrCb + LBP" in method:
                processed = clahe_ycrcb_lbp(img_bgr)
            elif "Histogram Equalization" in method:
                processed = histogram_equalization(img_bgr)
            
            # Convert back to RGB for display
            processed_rgb = cv2.cvtColor(processed, cv2.COLOR_BGR2RGB)
            
            # Display processed image in card
            with col2:
                st.markdown('<div class="image-card">', unsafe_allow_html=True)
                st.markdown("#### ‚ú® Enhanced Image")
                st.image(processed_rgb, width="stretch")
                st.markdown('</div>', unsafe_allow_html=True)
            
            # Success banner
            st.markdown("""
                <div class="success-banner">
                    ‚úÖ Processing Complete! Your enhanced image is ready for download.
                </div>
            """, unsafe_allow_html=True)
            
            # Convert to bytes for download
            processed_pil = Image.fromarray(processed_rgb)
            buf = io.BytesIO()
            processed_pil.save(buf, format="PNG")
            byte_im = buf.getvalue()
            
            # Download button in center
            download_col1, download_col2, download_col3 = st.columns([1, 2, 1])
            with download_col2:
                st.download_button(
                    label="‚¨áÔ∏è DOWNLOAD ENHANCED IMAGE",
                    data=byte_im,
                    file_name=f"enhanced_{method_choice.replace(' ', '_')}_{uploaded_file.name}",
                    mime="image/png",
                    width="stretch"
                )
            
            # Comparison metrics
            st.markdown("---")
            st.markdown("### üìà Enhancement Analysis")
            metric_col1, metric_col2, metric_col3 = st.columns(3)
            
            original_mean = np.mean(img_array)
            processed_mean = np.mean(processed_rgb)
            original_std = np.std(img_array)
            processed_std = np.std(processed_rgb)
            
            with metric_col1:
                st.metric("Mean Intensity Change", 
                         f"{processed_mean:.1f}", 
                         f"{processed_mean - original_mean:.1f}")
            with metric_col2:
                st.metric("Contrast (Std Dev)", 
                         f"{processed_std:.1f}", 
                         f"{processed_std - original_std:.1f}")
            with metric_col3:
                improvement = ((processed_std - original_std) / original_std * 100) if original_std > 0 else 0
                st.metric("Improvement", f"{abs(improvement):.1f}%")

else:
    # Empty state with instructions
    st.markdown("---")
    st.markdown("""
        <div style='text-align: center; padding: 3rem; background: white; border-radius: 15px; box-shadow: 0 8px 25px rgba(0,0,0,0.1);'>
            <h2 style='color: #667eea;'>ÔøΩ Welcome!</h2>
            <p style='font-size: 1.2rem; color: #555; margin: 1rem 0;'>
                Get started by uploading a medical image above
            </p>
            <p style='color: #888;'>
                üì∏ Supported formats: PNG, JPG, JPEG, TIFF<br>
                üéØ Perfect for X-rays, CT scans, and other medical imaging<br>
                ‚ö° Fast processing with professional results
            </p>
        </div>
    """, unsafe_allow_html=True)

# Footer
st.markdown("---")
st.markdown("""
    <div style='text-align: center; padding: 2.5rem; background: white; border-radius: 20px; 
                margin-top: 2rem; box-shadow: 0 4px 20px rgba(102, 126, 234, 0.08); 
                border: 1px solid #e8eef5;'>
        <h3 style='color: #667eea; margin-bottom: 1rem; font-weight: 700;'>üî¨ Medical Image Preprocessor</h3>
        <p style='color: #6c757d; margin-bottom: 0.5rem; font-size: 1rem;'>
            Professional AI-powered image enhancement for medical imaging
        </p>
        <p style='color: #adb5bd; font-size: 0.9rem;'>
            Built with ‚ù§Ô∏è using Streamlit | ¬© 2025 All Rights Reserved
        </p>
        <div style='margin-top: 1.5rem;'>
            <span style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                         color: white; padding: 0.6rem 1.2rem; border-radius: 25px; 
                         font-size: 0.85rem; font-weight: 600; letter-spacing: 0.5px;
                         box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);'>
                v1.0.0
            </span>
        </div>
    </div>
""", unsafe_allow_html=True)
